// backend/src/services/auditService.ts
// 21 CFR Part 11 Compliant Audit Trail Service

import { supabase } from '../config/supabase.js';

export interface AuditEntry {
    user_id: string;
    username?: string;
    action: 'CREATE' | 'UPDATE' | 'DELETE' | 'LOGIN' | 'LOGOUT' | 'DISPENSE' | 'RETURN' | 'DESTROY' | 'VIEW';
    table_name: string;
    record_id: string;
    old_values?: Record<string, any>;
    new_values?: Record<string, any>;
    reason_for_change?: string;
    ip_address?: string;
    user_agent?: string;
}

export interface AuditFilters {
    user_id?: string;
    action?: string;
    table_name?: string;
    record_id?: string;
    start_date?: string;
    end_date?: string;
    limit?: number;
    offset?: number;
}

/**
 * Log an audit entry - IMMUTABLE, cannot be modified or deleted
 */
export async function logAudit(entry: AuditEntry): Promise<void> {
    try {
        const { error } = await supabase
            .from('audit_log')
            .insert({
                user_id: entry.user_id,
                action: entry.action,
                table_name: entry.table_name,
                record_id: entry.record_id,
                changes_json: {
                    old_values: entry.old_values || null,
                    new_values: entry.new_values || null,
                    reason_for_change: entry.reason_for_change || null,
                    username: entry.username || null
                },
                ip_address: entry.ip_address || null,
                user_agent: entry.user_agent || null,
                // timestamp is auto-generated by database
            });

        if (error) {
            console.error('Failed to log audit entry:', error);
            // Don't throw - audit logging should not break the main operation
            // But log it for monitoring
        }
    } catch (err) {
        console.error('Audit logging error:', err);
    }
}

/**
 * Get audit logs with filtering
 */
export async function getAuditLogs(filters: AuditFilters = {}) {
    let query = supabase
        .from('audit_log')
        .select(`
            audit_id,
            user_id,
            action,
            table_name,
            record_id,
            changes_json,
            ip_address,
            user_agent,
            timestamp,
            user:users(username, email)
        `)
        .order('timestamp', { ascending: false });

    // Apply filters
    if (filters.user_id) {
        query = query.eq('user_id', filters.user_id);
    }
    if (filters.action) {
        query = query.eq('action', filters.action);
    }
    if (filters.table_name) {
        query = query.eq('table_name', filters.table_name);
    }
    if (filters.record_id) {
        query = query.eq('record_id', filters.record_id);
    }
    if (filters.start_date) {
        query = query.gte('timestamp', filters.start_date);
    }
    if (filters.end_date) {
        query = query.lte('timestamp', filters.end_date);
    }

    // Pagination
    const limit = filters.limit || 50;
    const offset = filters.offset || 0;
    query = query.range(offset, offset + limit - 1);

    const { data, error } = await query;

    if (error) throw error;
    return data;
}

/**
 * Get audit log count for pagination
 */
export async function getAuditLogCount(filters: AuditFilters = {}) {
    let query = supabase
        .from('audit_log')
        .select('audit_id', { count: 'exact', head: true });

    if (filters.user_id) {
        query = query.eq('user_id', filters.user_id);
    }
    if (filters.action) {
        query = query.eq('action', filters.action);
    }
    if (filters.table_name) {
        query = query.eq('table_name', filters.table_name);
    }
    if (filters.start_date) {
        query = query.gte('timestamp', filters.start_date);
    }
    if (filters.end_date) {
        query = query.lte('timestamp', filters.end_date);
    }

    const { count, error } = await query;

    if (error) throw error;
    return count || 0;
}

/**
 * Get a single audit entry by ID
 */
export async function getAuditEntry(auditId: number) {
    const { data, error } = await supabase
        .from('audit_log')
        .select(`
            *,
            user:users(username, email)
        `)
        .eq('audit_id', auditId)
        .single();

    if (error) throw error;
    return data;
}

/**
 * Format audit logs for CSV export
 */
export function formatAuditLogsForExport(logs: any[]) {
    return logs.map(log => ({
        'Audit ID': log.audit_id,
        'Timestamp': new Date(log.timestamp).toISOString(),
        'User': log.user?.username || log.changes_json?.username || 'Unknown',
        'Action': log.action,
        'Table': log.table_name,
        'Record ID': log.record_id,
        'Old Values': JSON.stringify(log.changes_json?.old_values || {}),
        'New Values': JSON.stringify(log.changes_json?.new_values || {}),
        'Reason for Change': log.changes_json?.reason_for_change || '',
        'IP Address': log.ip_address || ''
    }));
}

export default {
    logAudit,
    getAuditLogs,
    getAuditLogCount,
    getAuditEntry,
    formatAuditLogsForExport
};
